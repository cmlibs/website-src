<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="classCMLibs_1_1Zinc_1_1Fieldmodule" kind="class" language="C++" prot="public">
    <compoundname>CMLibs::Zinc::Fieldmodule</compoundname>
    <includes refid="fieldmodule_8hpp" local="no">fieldmodule.hpp</includes>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a59632afdf74a7382ba91aacbc943eb99" prot="private" static="no" mutable="no">
        <type>cmzn_fieldmodule_id</type>
        <definition>cmzn_fieldmodule_id CMLibs::Zinc::Fieldmodule::id</definition>
        <argsstring></argsstring>
        <name>id</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="138" column="21" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="138" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae4a5b3936bc1ea6658a8cb1f3bf34b11" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>CMLibs::Zinc::Fieldmodule::Fieldmodule</definition>
        <argsstring>()</argsstring>
        <name>Fieldmodule</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="142" column="1" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="142" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1676e97931c0bf1cde040462779994fc" prot="public" static="no" const="no" explicit="yes" inline="yes" virt="non-virtual">
        <type></type>
        <definition>CMLibs::Zinc::Fieldmodule::Fieldmodule</definition>
        <argsstring>(cmzn_fieldmodule_id field_module_id)</argsstring>
        <name>Fieldmodule</name>
        <param>
          <type>cmzn_fieldmodule_id</type>
          <declname>field_module_id</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="146" column="10" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="146" bodyend="148"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aad80e24a6f41d7c031aaaf30d1bdfffa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>CMLibs::Zinc::Fieldmodule::Fieldmodule</definition>
        <argsstring>(const Fieldmodule &amp;fieldModule)</argsstring>
        <name>Fieldmodule</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule" kindref="compound">Fieldmodule</ref> &amp;</type>
          <declname>fieldModule</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="150" column="1" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="150" bodyend="152"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa5418aff205c69f844077b080277fe3b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule" kindref="compound">Fieldmodule</ref> &amp;</type>
        <definition>Fieldmodule&amp; CMLibs::Zinc::Fieldmodule::operator=</definition>
        <argsstring>(const Fieldmodule &amp;fieldModule)</argsstring>
        <name>operator=</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule" kindref="compound">Fieldmodule</ref> &amp;</type>
          <declname>fieldModule</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="154" column="13" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="154" bodyend="163"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a655de99144d9b50827f6426158150ef4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>CMLibs::Zinc::Fieldmodule::~Fieldmodule</definition>
        <argsstring>()</argsstring>
        <name>~Fieldmodule</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="165" column="1" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="165" bodyend="171"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1adeb193f51bd236e99150fa49c1a3bf59" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool CMLibs::Zinc::Fieldmodule::isValid</definition>
        <argsstring>() const</argsstring>
        <name>isValid</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Check if this is a valid <ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule" kindref="compound">Fieldmodule</ref> object.</para>
<para><simplesect kind="return"><para>Status True if object is valid, false otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="178" column="6" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="178" bodyend="181"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ade54775b505383dd3eb5671eeb34a76a" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>cmzn_fieldmodule_id</type>
        <definition>cmzn_fieldmodule_id CMLibs::Zinc::Fieldmodule::getId</definition>
        <argsstring>() const</argsstring>
        <name>getId</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Return the C handle of the <ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule" kindref="compound">Fieldmodule</ref> object.</para>
<para><simplesect kind="return"><para>C handle of <ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule" kindref="compound">Fieldmodule</ref> if this objects is valid, 0 otherwise. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="188" column="21" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="188" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5a5ece70513615b1389587cf1351abff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int CMLibs::Zinc::Fieldmodule::beginChange</definition>
        <argsstring>()</argsstring>
        <name>beginChange</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Begin caching or increment cache level for this field module. Call this function before making multiple changes to fields, nodes, elements etc. from this field module to minimise number of change messages sent to clients. Must call matching fieldmodule end change method after making changes. Note that field module changes are always cached when the region changes are being cached. Can be nested. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9629b9e5c0cd91488c1a01ccee079a64" kindref="member">Fieldmodule::endChange</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Region_1a942c62b8b068524e1725bbaff79e9467" kindref="member">Region::beginChange</ref></para>
</simplesect>
<simplesect kind="return"><para>Status <ref refid="namespaceCMLibs_1_1Zinc_1af8a9881f3a06e3e24858b11ddb3f6de9a4f1327b31c1f572158bfee8728e553e8" kindref="member">CMLibs::Zinc::OK</ref> on success, any other value on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="205" column="5" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="205" bodyend="208"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9629b9e5c0cd91488c1a01ccee079a64" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int CMLibs::Zinc::Fieldmodule::endChange</definition>
        <argsstring>()</argsstring>
        <name>endChange</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Decrement cache level or end caching of changes for this field module. Call matching fieldmodule begin change method before making multiple changes and call this afterwards. When change level is restored to zero, cached change messages are sent out to clients. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5a5ece70513615b1389587cf1351abff" kindref="member">Fieldmodule::beginChange</ref></para>
</simplesect>
<simplesect kind="return"><para>Status <ref refid="namespaceCMLibs_1_1Zinc_1af8a9881f3a06e3e24858b11ddb3f6de9a4f1327b31c1f572158bfee8728e553e8" kindref="member">CMLibs::Zinc::OK</ref> on success, any other value on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="219" column="5" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="219" bodyend="222"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5012fd4644c9b3e6eb63ac665306abaa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int CMLibs::Zinc::Fieldmodule::defineAllFaces</definition>
        <argsstring>()</argsstring>
        <name>defineAllFaces</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Defines, for all elements of all meshes in field module, face elements of dimension one lower in the associated face mesh, and all their faces recursively down to 1 dimensional lines.</para>
<para>faces for. <simplesect kind="return"><para>Result OK on success, WARNING_PART_DONE if failed on some elements due to not having nodes set, otherwise any other error. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="233" column="5" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="233" bodyend="236"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae426524c3e12a5bd06695e66d9ca43ba" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref></type>
        <definition>Field CMLibs::Zinc::Fieldmodule::findFieldByName</definition>
        <argsstring>(const char *fieldName) const</argsstring>
        <name>findFieldByName</name>
        <param>
          <type>const char *</type>
          <declname>fieldName</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Returns the field of the specified name from the field module.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fieldName</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the field to find. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to field, or NULL/invalid handle if not found or failed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="244" column="7" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="244" bodyend="247"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a86b366b0c3487fea69112a1db342ed26" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Fieldcache" kindref="compound">Fieldcache</ref></type>
        <definition>Fieldcache CMLibs::Zinc::Fieldmodule::createFieldcache</definition>
        <argsstring>()</argsstring>
        <name>createFieldcache</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field cache for storing a known location and field values and derivatives at that location. Required to evaluate and assign field values.</para>
<para><simplesect kind="return"><para>Handle to new field cache, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="255" column="19" bodyfile="auto_comments_output/fieldcache.hpp" bodystart="199" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1573bb82ca9c8b5d8a612e7b9eeed282" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Fielditerator" kindref="compound">Fielditerator</ref></type>
        <definition>Fielditerator CMLibs::Zinc::Fieldmodule::createFielditerator</definition>
        <argsstring>()</argsstring>
        <name>createFielditerator</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a field iterator object for iterating through the fields in the field module, in alphabetical order of name. The iterator initially points at the position before the first field, so the first call to the field iterator next() method returns the first field and advances the iterator. Iterator becomes invalid if fields are added, removed or renamed while in use. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fielditerator_1a9ddccbc36f1767f47d2704555e8fe5c0" kindref="member">Fielditerator::next</ref></para>
</simplesect>
iterated over. <simplesect kind="return"><para>Handle to field iterator, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="268" column="15" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="268" bodyend="271"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac961e552c6eb79996528618a12654669" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodulenotifier" kindref="compound">Fieldmodulenotifier</ref></type>
        <definition>Fieldmodulenotifier CMLibs::Zinc::Fieldmodule::createFieldmodulenotifier</definition>
        <argsstring>()</argsstring>
        <name>createFieldmodulenotifier</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a notifier for getting callbacks for changes to the fields and related objects in the field module.</para>
<para><simplesect kind="return"><para>Handle to new field module notifier, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="279" column="21" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="1799" bodyend="1802"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ab9c9aca09fd1daacb42ead12c40788b2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Fieldsmoothing" kindref="compound">Fieldsmoothing</ref></type>
        <definition>Fieldsmoothing CMLibs::Zinc::Fieldmodule::createFieldsmoothing</definition>
        <argsstring>()</argsstring>
        <name>createFieldsmoothing</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create a new field smoothing object using the default algorithm. <simplesect kind="see"><para>cmzn_fieldsmoothing_algorithm </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fieldsmoothing_1a90db6544e62990def817782d20c7e086" kindref="member">Fieldsmoothing::setAlgorithm</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Field_1a3cc6edbc68ea5c5492b28f1b285fc432" kindref="member">Field::smooth</ref></para>
</simplesect>
<simplesect kind="return"><para>Handle to new field smoothing, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="289" column="23" bodyfile="auto_comments_output/fieldsmoothing.hpp" bodystart="119" bodyend="122"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1acc766d868e3821e012a3e87d343f72f0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Elementbasis" kindref="compound">Elementbasis</ref></type>
        <definition>Elementbasis CMLibs::Zinc::Fieldmodule::createElementbasis</definition>
        <argsstring>(int dimension, Elementbasis::FunctionType functionType)</argsstring>
        <name>createElementbasis</name>
        <param>
          <type>int</type>
          <declname>dimension</declname>
        </param>
        <param>
          <type><ref refid="classCMLibs_1_1Zinc_1_1Elementbasis_1a69ca529f75d14331dffe6fbc13a3c6e4" kindref="member">Elementbasis::FunctionType</ref></type>
          <declname>functionType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates an element_basis object for describing element basis functions.</para>
<para>used to define fields in any field module of the region tree. <parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>The dimension of element chart the basis is for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>functionType</parametername>
</parameternamelist>
<parameterdescription>
<para>The basis function type to use in each dimension i.e. basis function is initially homogeneous. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new element basis, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="300" column="14" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="300" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1af6c34d0a96ef65be3ceefc65badab669" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref></type>
        <definition>Nodeset CMLibs::Zinc::Fieldmodule::findNodesetByFieldDomainType</definition>
        <argsstring>(Field::DomainType domainType) const</argsstring>
        <name>findNodesetByFieldDomainType</name>
        <param>
          <type><ref refid="classCMLibs_1_1Zinc_1_1Field_1a66a5de518fc4bb28be98f05d2c964cd6" kindref="member">Field::DomainType</ref></type>
          <declname>domainType</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a handle to a nodeset by its field domain type, either CMZN_FIELD_DOMAIN_TYPE_NODES or CMZN_FIELD_DOMAIN_TYPE_DATAPOINTS.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>domainType</parametername>
</parameternamelist>
<parameterdescription>
<para>CMZN_FIELD_DOMAIN_TYPE_NODES or CMZN_FIELD_DOMAIN_TYPE_DATAPOINTS. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to the nodeset, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="313" column="9" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="313" bodyend="317"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1653b3a43ce3aee0aea16af76379632e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref></type>
        <definition>Nodeset CMLibs::Zinc::Fieldmodule::findNodesetByName</definition>
        <argsstring>(const char *nodeset_name) const</argsstring>
        <name>findNodesetByName</name>
        <param>
          <type>const char *</type>
          <declname>nodeset_name</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a handle to a nodeset from its name in the field module. A nodeset is the container of nodes - i.e. cmzn_node objects. Valid names may be any node_group field, or the following special names: &quot;nodes&quot; = the primary set of nodes for a region, able to be indexed by elements for storing or mapping to finite element field parameters. &quot;datapoints&quot; = an additional set of nodes generally used to represent data points, not for finite element field parameters. Note that the default names for node group fields created from a group is GROUP_NAME.NODESET_NAME, with nodeset names as above.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>nodeset_name</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the nodeset. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to the nodeset, or NULL/invalid handle if not found or failed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="333" column="9" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="333" bodyend="337"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a6dc9e09c4fecc6eb8cd06f074bd964ea" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Mesh" kindref="compound">Mesh</ref></type>
        <definition>Mesh CMLibs::Zinc::Fieldmodule::findMeshByDimension</definition>
        <argsstring>(int dimension) const</argsstring>
        <name>findMeshByDimension</name>
        <param>
          <type>int</type>
          <declname>dimension</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a handle to the default mesh of a given dimension. Cmgui is currently limited to 1 mesh of each dimension from 1 to 3. These meshes have default names of &quot;mesh_Nd&quot;, where &quot;N&quot; is the dimension.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dimension</parametername>
</parameternamelist>
<parameterdescription>
<para>The dimension of the mesh from 1 to 3. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to the mesh, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="347" column="6" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="347" bodyend="350"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac037ebc7e67c3fa9e1a56cbca0f1a368" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Mesh" kindref="compound">Mesh</ref></type>
        <definition>Mesh CMLibs::Zinc::Fieldmodule::findMeshByName</definition>
        <argsstring>(const char *meshName) const</argsstring>
        <name>findMeshByName</name>
        <param>
          <type>const char *</type>
          <declname>meshName</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Get a handle to a finite element mesh from its name. A mesh is the container of elements of a fixed dimension. Valid names may be any element_group field, or any of the following special names: &quot;mesh3d&quot; = 3-D elements. &quot;mesh2d&quot; = 2-D elements including faces of 3-D elements. &quot;mesh1d&quot; = 1-D elements including faces (lines) of 2-D elements. Note that the default names for element group fields created from a group is GROUP_NAME.MESH_NAME, with mesh names as above.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>meshName</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the finite element mesh. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to the mesh, or NULL/invalid handle if not found or failed. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="365" column="6" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="365" bodyend="368"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a33fd27adce35d2ed8277a4515197abc6" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>char *</type>
        <definition>char* CMLibs::Zinc::Fieldmodule::writeDescription</definition>
        <argsstring>() const</argsstring>
        <name>writeDescription</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the json file describing the fields in this fieldmodule, which can be used to store the current cmzn_field settings.</para>
<para><simplesect kind="return"><para>c string containing the json description of fieldmodule, otherwise 0; </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="376" column="6" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="376" bodyend="379"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a31dfb31d8d058a749dad0c8ac358d3ee" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int CMLibs::Zinc::Fieldmodule::readDescription</definition>
        <argsstring>(const char *description)</argsstring>
        <name>readDescription</name>
        <param>
          <type>const char *</type>
          <declname>description</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Write the json file describing the fields in this fieldmodule. This may change the current fields&apos; definition.</para>
<para>@description The string containing json description <simplesect kind="return"><para><ref refid="namespaceCMLibs_1_1Zinc_1af8a9881f3a06e3e24858b11ddb3f6de9a4f1327b31c1f572158bfee8728e553e8" kindref="member">CMLibs::Zinc::OK</ref> on success, otherwise ERROR status. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="388" column="5" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="388" bodyend="391"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2cde509da78fd6a758ed7126307e5808" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Timesequence" kindref="compound">Timesequence</ref></type>
        <definition>Timesequence CMLibs::Zinc::Fieldmodule::getMatchingTimesequence</definition>
        <argsstring>(int timesCount, const double *timesIn)</argsstring>
        <name>getMatchingTimesequence</name>
        <param>
          <type>int</type>
          <declname>timesCount</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>timesIn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Finds or creates a time sequence in the field module which matches the sequence of times provided.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timesInCount</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the times array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timesIn</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of times. Note later times must not be less than earlier times. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to time sequence matching times array, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="403" column="21" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="403" bodyend="407"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a76758a25dfb1da91ab90ced1f5c448bb" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Region" kindref="compound">Region</ref></type>
        <definition>Region CMLibs::Zinc::Fieldmodule::getRegion</definition>
        <argsstring>() const</argsstring>
        <name>getRegion</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Gets the region this field module can create fields for.</para>
<para><simplesect kind="return"><para>Handle to owning region, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="414" column="15" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="414" bodyend="417"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ada3f248f916b5c561e0e567954574476" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1Optimisation" kindref="compound">Optimisation</ref></type>
        <definition>Optimisation CMLibs::Zinc::Fieldmodule::createOptimisation</definition>
        <argsstring>()</argsstring>
        <name>createOptimisation</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Create an optimisation object for optimising values and parameters of fields from a field module.</para>
<para><simplesect kind="return"><para>Handle to new optimisation, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="425" column="21" bodyfile="auto_comments_output/optimisation.hpp" bodystart="521" bodyend="524"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae4f27ddaff29135583831224eec64d4d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldApply" kindref="compound">FieldApply</ref></type>
        <definition>FieldApply CMLibs::Zinc::Fieldmodule::createFieldApply</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldApply</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a zinc field which applies the function of the supplied field, optionally binding argument fields it depends on to other source fields. This is the main mechanism for reusing field definitions from other regions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field which this field will evaluate. Can be from a different region. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="437" column="19" bodyfile="auto_comments_output/fieldapply.hpp" bodystart="141" bodyend="145"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa5d3836ac0092c6d5147f65b9263e4a5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldArgumentReal" kindref="compound">FieldArgumentReal</ref></type>
        <definition>FieldArgumentReal CMLibs::Zinc::Fieldmodule::createFieldArgumentReal</definition>
        <argsstring>(int numberOfComponents)</argsstring>
        <name>createFieldArgumentReal</name>
        <param>
          <type>int</type>
          <declname>numberOfComponents</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field representing a multi-component real-valued argument to other fields defining reusable operators acting on it. Works exclusively with an Apply field which can evaluate the operator field by binding all arguments. The Argument field type delegates its evaluation to the field currently bound to it in the field cache.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numberOfComponents</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of real components of the field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="449" column="26" bodyfile="auto_comments_output/fieldapply.hpp" bodystart="152" bodyend="156"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1adb0d75da2f36cbb1e753142f196e79d3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAdd" kindref="compound">FieldAdd</ref></type>
        <definition>FieldAdd CMLibs::Zinc::Fieldmodule::createFieldAdd</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldAdd</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the which adds the components of source_field_one and source_field_two. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="460" column="17" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="275" bodyend="279"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a669caf254dd908d32922da01dc9aa67d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldPower" kindref="compound">FieldPower</ref></type>
        <definition>FieldPower CMLibs::Zinc::Fieldmodule::createFieldPower</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldPower</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the which calculates the components of source_field_one raised to the power of the components in source_field_two. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="471" column="19" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="281" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae2459e5418ae59427d113c417ff06058" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldMultiply" kindref="compound">FieldMultiply</ref></type>
        <definition>FieldMultiply CMLibs::Zinc::Fieldmodule::createFieldMultiply</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldMultiply</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the which multiplies the components of source_field_one and source_field_two. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="482" column="22" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="287" bodyend="291"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad55ea71f4ccf1ac12aaae7b9813bc02e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldDivide" kindref="compound">FieldDivide</ref></type>
        <definition>FieldDivide CMLibs::Zinc::Fieldmodule::createFieldDivide</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldDivide</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the which divides the components of source_field_one by source_field_two. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="493" column="20" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="293" bodyend="297"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a833a19d7bf1a31aba06dc247752eb518" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldSubtract" kindref="compound">FieldSubtract</ref></type>
        <definition>FieldSubtract CMLibs::Zinc::Fieldmodule::createFieldSubtract</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldSubtract</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which gives the result of subtracting source_field_two from source_field_one. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="504" column="22" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="299" bodyend="303"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad1e2af3827f21a2547edcbe1baa6d1a7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldSumComponents" kindref="compound">FieldSumComponents</ref></type>
        <definition>FieldSumComponents CMLibs::Zinc::Fieldmodule::createFieldSumComponents</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldSumComponents</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which has one component equal to the sum of all components of the source field. Also called the L1, taxicab or manhattan norm. For weighted sum of components use a dot_product with a constant weights field. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a13bbdbbcbbc60e180e69a173f2b20704" kindref="member">Fieldmodule::createFieldDotProduct</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field whose components are to be summed. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="515" column="27" bodyfile="auto_comments_output/fieldvectoroperators.hpp" bodystart="184" bodyend="188"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ada50786d7a8ed39b0bbbcbbdcd6ea64f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldLog" kindref="compound">FieldLog</ref></type>
        <definition>FieldLog CMLibs::Zinc::Fieldmodule::createFieldLog</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldLog</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the field components are the natural logarithm of each component in the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="524" column="17" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="305" bodyend="308"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a0e8e9dd60877b4d49777d7ea764da322" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldSqrt" kindref="compound">FieldSqrt</ref></type>
        <definition>FieldSqrt CMLibs::Zinc::Fieldmodule::createFieldSqrt</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldSqrt</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the field components are the square root of each component in the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="533" column="18" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="310" bodyend="313"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2afd6351d30e89765859f51f68bfbcec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldExp" kindref="compound">FieldExp</ref></type>
        <definition>FieldExp CMLibs::Zinc::Fieldmodule::createFieldExp</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldExp</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the field components are the natural exponent of each component in the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="542" column="17" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="315" bodyend="318"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1afa5a78d8c8ba22510b4f327b23e7195a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAbs" kindref="compound">FieldAbs</ref></type>
        <definition>FieldAbs CMLibs::Zinc::Fieldmodule::createFieldAbs</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldAbs</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the field components are the absolute value of each component in the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="551" column="17" bodyfile="auto_comments_output/fieldarithmeticoperators.hpp" bodystart="320" bodyend="323"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9e6a92b449cc3ecd9ba0ff01a6eada54" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldIdentity" kindref="compound">FieldIdentity</ref></type>
        <definition>FieldIdentity CMLibs::Zinc::Fieldmodule::createFieldIdentity</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldIdentity</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field with the single source field. This field is useful as a placeholder candidate for replacement with more complicated operations later on. Internally this a composite field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field the values are copied from. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="562" column="22" bodyfile="auto_comments_output/fieldcomposite.hpp" bodystart="148" bodyend="151"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a13e59f1bb2dd5a459d7b32aa845406b3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldComponent" kindref="compound">FieldComponent</ref></type>
        <definition>FieldComponent CMLibs::Zinc::Fieldmodule::createFieldComponent</definition>
        <argsstring>(const Field &amp;sourceField, int sourceComponentIndex)</argsstring>
        <name>createFieldComponent</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sourceComponentIndex</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a component-type field returning a single component of the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field the component value is copied from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceComponentIndex</parametername>
</parameternamelist>
<parameterdescription>
<para>The component index from 1 to number of components of the source field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="573" column="23" bodyfile="auto_comments_output/fieldcomposite.hpp" bodystart="153" bodyend="157"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac7e484c86476176a8f6dddda1450b0d9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldComponent" kindref="compound">FieldComponent</ref></type>
        <definition>FieldComponent CMLibs::Zinc::Fieldmodule::createFieldComponent</definition>
        <argsstring>(const Field &amp;sourceField, int sourceComponentIndexesCount, const int *sourceComponentIndexesIn)</argsstring>
        <name>createFieldComponent</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>int</type>
          <declname>sourceComponentIndexesCount</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>sourceComponentIndexesIn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a component-type field returning a single component of the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field the component value is copied from. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceComponentIndexesCount</parametername>
</parameternamelist>
<parameterdescription>
<para>The component index from 1 to number of components of the source field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="584" column="23" bodyfile="auto_comments_output/fieldcomposite.hpp" bodystart="159" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a484001251e3080b80526500e214fd3cf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldConcatenate" kindref="compound">FieldConcatenate</ref></type>
        <definition>FieldConcatenate CMLibs::Zinc::Fieldmodule::createFieldConcatenate</definition>
        <argsstring>(int fieldsCount, const Field *sourceFields)</argsstring>
        <name>createFieldConcatenate</name>
        <param>
          <type>int</type>
          <declname>fieldsCount</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> *</type>
          <declname>sourceFields</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which concatenates the components of all source fields, in order, into a single vector.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fieldsCount</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of source fields in the array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceFields</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of fields to be concatenated together. The implementation consolidates repeated fields into common source fields. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="596" column="25" bodyfile="auto_comments_output/fieldcomposite.hpp" bodystart="172" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a57d403518c146728ef0f53707ea19262" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldIf" kindref="compound">FieldIf</ref></type>
        <definition>FieldIf CMLibs::Zinc::Fieldmodule::createFieldIf</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2, const Field &amp;sourceField3)</argsstring>
        <name>createFieldIf</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField3</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a conditional field returning component values from source field two if the condition source field one is true, otherwise source field three. The field has the value type and number of components from source fields two and three, which must match. Source fields two and three of mesh location value type must have matching host mesh. For real value type, the condition field may be a vector of same length as the other two source fields, in which case the condition is applied per- component: a non-zero/true component gives the corresponding component value from source field two, zero/false gives the value from source field three.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>Condition field. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> components returned on true condition. Must have same value type and number of components as source_field_three. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField3</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> components returned on false condition. Must have same value type and number of components as source_field_two. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="616" column="16" bodyfile="auto_comments_output/fieldconditional.hpp" bodystart="51" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac351d583857d1576f81a3dbfc66d8918" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldConstant" kindref="compound">FieldConstant</ref></type>
        <definition>FieldConstant CMLibs::Zinc::Fieldmodule::createFieldConstant</definition>
        <argsstring>(int valuesCount, const double *valuesIn)</argsstring>
        <name>createFieldConstant</name>
        <param>
          <type>int</type>
          <declname>valuesCount</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>valuesIn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field with the components specified in the array values. Internally this a composite field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>valuesInCount</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of values in the array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>valuesIn</parametername>
</parameternamelist>
<parameterdescription>
<para>The array of constant values </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="626" column="22" bodyfile="auto_comments_output/fieldconstant.hpp" bodystart="45" bodyend="49"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aeabaf2f7786787070e0d024da7eb4721" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldStringConstant" kindref="compound">FieldStringConstant</ref></type>
        <definition>FieldStringConstant CMLibs::Zinc::Fieldmodule::createFieldStringConstant</definition>
        <argsstring>(const char *stringConstant)</argsstring>
        <name>createFieldStringConstant</name>
        <param>
          <type>const char *</type>
          <declname>stringConstant</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a string constant field with the supplied string value in &lt;string_constant&gt;.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stringConstant</parametername>
</parameternamelist>
<parameterdescription>
<para>The constant char string. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="635" column="28" bodyfile="auto_comments_output/fieldconstant.hpp" bodystart="75" bodyend="79"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa9154e8ea1fad2d89206201f4c0139e6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldCoordinateTransformation" kindref="compound">FieldCoordinateTransformation</ref></type>
        <definition>FieldCoordinateTransformation CMLibs::Zinc::Fieldmodule::createFieldCoordinateTransformation</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldCoordinateTransformation</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which performs a coordinate transformation from the source field values in their coordinate system type into the coordinate system type of this field. Returned field has 3 components. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Field_1a8d01b1bff6eaa0d8860c0ac6a393f614" kindref="member">Field::setCoordinateSystemType</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source field with values in its own coordinate system. Must have 1 to 3 components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="647" column="38" bodyfile="auto_comments_output/fieldcoordinatetransformation.hpp" bodystart="73" bodyend="78"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a0d002b996c78cd826e9ad74a502c3d26" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldVectorCoordinateTransformation" kindref="compound">FieldVectorCoordinateTransformation</ref></type>
        <definition>FieldVectorCoordinateTransformation CMLibs::Zinc::Fieldmodule::createFieldVectorCoordinateTransformation</definition>
        <argsstring>(const Field &amp;vectorField, const Field &amp;coordinateField)</argsstring>
        <name>createFieldVectorCoordinateTransformation</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>vectorField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which performs a coordinate transformation of vectors from their original coordinate system and coordinate positions, to the coordinate system of this field. Sets the number of components in returned field to 3 times the number of vectors expected from the source vector_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vectorField</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector field to be transformed. Can be a single vector (1,2 or 3 components), two vectors (4 or 6 components) or three vectors (9 components). </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> giving location where vector value is from. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="661" column="44" bodyfile="auto_comments_output/fieldcoordinatetransformation.hpp" bodystart="80" bodyend="85"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a6831ea6e179a9b95cb26dfa0f5d4dc75" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldFibreAxes" kindref="compound">FieldFibreAxes</ref></type>
        <definition>FieldFibreAxes CMLibs::Zinc::Fieldmodule::createFieldFibreAxes</definition>
        <argsstring>(const Field &amp;fibreField, const Field &amp;coordinateField)</argsstring>
        <name>createFieldFibreAxes</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>fibreField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a &quot;fibre axes&quot; field type which returns a 9-component (3 x 3 vector) field representing an orthonormal coordinate system which is rotated by 3 Euler angles supplied by a fibre field. Three resulting 3 axes are: fibre = fibre direction sheet = fibre normal in the plane of the sheet normal = normal to the fibre sheet Both the fibre and coordinate fields must have no more than 3 components. The fibre field is expected to have a FIBRE coordinate_system, although this is not enforced. Note that this initial orientation of the coordinate system (i.e. for all Euler angles zero) is right handed coordinate system: fibre axis = aligned with d(coordinates)/dxi1 sheet axis = in plane of fibre axis and d(coordinates)/dxi2 but corrected to be closest vector to d(coordinates)/dxi2 which is normal to fibre axes. normal axis = cross product fibre (x) sheet How the components of the fibre angles rotate the above system is described with the FIBRE coordinate system. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Field_1ab43cb98275e1f9017786a31b7b3551cb" kindref="member">Field::CoordinateSystemType</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fibreField</parametername>
</parameternamelist>
<parameterdescription>
<para>The (numerical) fibre field with at most 3 components </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para>The (numerical) coordinate system with at most 3 components </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new 9-component field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="688" column="23" bodyfile="auto_comments_output/fieldfibres.hpp" bodystart="60" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5ecc267b21519b2be0ee27e7fec3b983" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldFiniteElement" kindref="compound">FieldFiniteElement</ref></type>
        <definition>FieldFiniteElement CMLibs::Zinc::Fieldmodule::createFieldFiniteElement</definition>
        <argsstring>(int numberOfComponents)</argsstring>
        <name>createFieldFiniteElement</name>
        <param>
          <type>int</type>
          <declname>numberOfComponents</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a real-valued finite_element field which can be interpolated over a finite element mesh with parameters indexed by nodes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numberOfComponents</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of components for the new field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="697" column="27" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="639" bodyend="643"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aad294a32dd7da04a40439f3672c92b88" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldEmbedded" kindref="compound">FieldEmbedded</ref></type>
        <definition>FieldEmbedded CMLibs::Zinc::Fieldmodule::createFieldEmbedded</definition>
        <argsstring>(const Field &amp;sourceField, const Field &amp;embeddedLocationField)</argsstring>
        <name>createFieldEmbedded</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>embeddedLocationField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning a value of a source field at an embedded location. The new field has the same value type as the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to evaluate at the embedded location. Currently restricted to having numerical values. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>embeddedLocationField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> returning an embedded location, i.e. find_mesh_location or stored mesh location fields. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="709" column="22" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="662" bodyend="666"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1f0296d5ccf785372e9dcf20325858d1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldEdgeDiscontinuity" kindref="compound">FieldEdgeDiscontinuity</ref></type>
        <definition>FieldEdgeDiscontinuity CMLibs::Zinc::Fieldmodule::createFieldEdgeDiscontinuity</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldEdgeDiscontinuity</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field producing a value on 1-D line elements with as many components as the source field, which gives the discontinuity of that field between two adjacent surfaces by a chosen measure. An optional conditional field restricts which adjacent surfaces qualify, with the first two used. The field values are zero when the surfaces are continuous by the chosen measure, and when there are fewer than two qualifying adjacent surfaces. The default measure of discontinuity is C1. In optimisation problems, adding an objective field consisting of the integral of [squares of] this field over a 1-D mesh will favour high- continuity solutions. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1FieldEdgeDiscontinuity_1a3fe7eb5fe709b50c7fedef74bbc763be" kindref="member">FieldEdgeDiscontinuity::Measure</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1FieldEdgeDiscontinuity_1ae14bf27ccdc648f54b7957d79adc1d94" kindref="member">FieldEdgeDiscontinuity::setMeasure</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1FieldEdgeDiscontinuity_1adbb6f422eb9ff9df4dd330320dfbf114" kindref="member">FieldEdgeDiscontinuity::setConditionalField</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The source field to measure discontinuity of. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="729" column="31" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="650" bodyend="655"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5d9caf67a46f1229470ece3f05e3a7e1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldFindMeshLocation" kindref="compound">FieldFindMeshLocation</ref></type>
        <definition>FieldFindMeshLocation CMLibs::Zinc::Fieldmodule::createFieldFindMeshLocation</definition>
        <argsstring>(const Field &amp;sourceField, const Field &amp;meshField, const Mesh &amp;mesh)</argsstring>
        <name>createFieldFindMeshLocation</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>meshField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Mesh" kindref="compound">Mesh</ref> &amp;</type>
          <declname>mesh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the location in a mesh at which the calculated source_field value equals the mesh_field value. Its values consist of an element and coordinates in the element&apos;s local &apos;xi&apos; coordinate chart. Type-specific functions allow the search to find the nearest value and set the search mesh to be different e.g. to limit to a subset mesh such as faces or lines. Note this is only designed to work for mesh field functions up to cubic polynomial complexity, and may not be accurate for fields with higher order waviness or extreme distortions.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source field whose value is to be searched for. Must have the same number of numerical components as the mesh_field, and at least as many as mesh dimension. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>meshField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> defined over the mesh which is to be matched with source_field. Must have the same number of numerical components as the source_field, and at least as many as mesh dimension. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mesh</parametername>
</parameternamelist>
<parameterdescription>
<para>The mesh to find and store locations in. The search mesh is initially set to this mesh, but can be changed, e.g. to find locations on a face mesh (the search mesh) and store them on a 3D mesh (e.g. this mesh). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="753" column="30" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="668" bodyend="673"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a27fe2d062e7d97f06287273e104d05f5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodeValue" kindref="compound">FieldNodeValue</ref></type>
        <definition>FieldNodeValue CMLibs::Zinc::Fieldmodule::createFieldNodeValue</definition>
        <argsstring>(const Field &amp;sourceField, Node::ValueLabel nodeValueLabel, int versionNumber)</argsstring>
        <name>createFieldNodeValue</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type><ref refid="classCMLibs_1_1Zinc_1_1Node_1aadd6c4bfe6c97b4e09e8cc1ca9f0a378" kindref="member">Node::ValueLabel</ref></type>
          <declname>nodeValueLabel</declname>
        </param>
        <param>
          <type>int</type>
          <declname>versionNumber</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which represents and returns labelled node parameters, i.e. specific value/derivative versions. This field has as many components as the source field, and is defined if any component has the specified value/derivative version. Non-existent component parameters evaluate to zero, and are ignored on assignment.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field for which the nodal values are stored, this must be a finite element field. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeValueLabel</parametername>
</parameternamelist>
<parameterdescription>
<para>The label of the node value/derivative to return. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>versionNumber</parametername>
</parameternamelist>
<parameterdescription>
<para>The version number of the value or derivative to return, starting from 1. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="770" column="23" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="680" bodyend="686"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae5e573ea86de6957d5905ec0887ef13d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldStoredMeshLocation" kindref="compound">FieldStoredMeshLocation</ref></type>
        <definition>FieldStoredMeshLocation CMLibs::Zinc::Fieldmodule::createFieldStoredMeshLocation</definition>
        <argsstring>(const Mesh &amp;mesh)</argsstring>
        <name>createFieldStoredMeshLocation</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Mesh" kindref="compound">Mesh</ref> &amp;</type>
          <declname>mesh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which stores and returns mesh location values at nodes. Its values consists of an element and coordinates in the element&apos;s local &apos;xi&apos; coordinate chart.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>mesh</parametername>
</parameternamelist>
<parameterdescription>
<para>The mesh for which locations are stored. Currently limited to a mesh from the same region. Note that if a mesh group is passed, the master mesh is used. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="783" column="32" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="693" bodyend="697"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aeff9cbb2d1f911125100c4b7328e1031" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldStoredString" kindref="compound">FieldStoredString</ref></type>
        <definition>FieldStoredString CMLibs::Zinc::Fieldmodule::createFieldStoredString</definition>
        <argsstring>()</argsstring>
        <name>createFieldStoredString</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which stores and returns string values at nodes.</para>
<para><simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="790" column="26" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="704" bodyend="708"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a942f81bdce4433198b3d9a85cdcc5416" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldIsExterior" kindref="compound">FieldIsExterior</ref></type>
        <definition>FieldIsExterior CMLibs::Zinc::Fieldmodule::createFieldIsExterior</definition>
        <argsstring>()</argsstring>
        <name>createFieldIsExterior</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which returns 1 on 2-D faces and 1-D lines considered as exterior to their top-level element, and 0 elsewhere.</para>
<para><simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="798" column="24" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="715" bodyend="718"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a3a4a4d38f3237eef5592a3fa1c436d5f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldIsOnFace" kindref="compound">FieldIsOnFace</ref></type>
        <definition>FieldIsOnFace CMLibs::Zinc::Fieldmodule::createFieldIsOnFace</definition>
        <argsstring>(Element::FaceType face)</argsstring>
        <name>createFieldIsOnFace</name>
        <param>
          <type><ref refid="classCMLibs_1_1Zinc_1_1Element_1ab4ebfa2abad2dca7196a327b7df84dc9" kindref="member">Element::FaceType</ref></type>
          <declname>face</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which returns 1 on 2-D faces and 1-D lines considered to lie on a specified face of their top-level element, and 0 elsewhere.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>face</parametername>
</parameternamelist>
<parameterdescription>
<para>The enumerated face type, defined with respect to the top-level element. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="808" column="22" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="720" bodyend="725"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ab0193597652fab2717094068651dfdd1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldGroup" kindref="compound">FieldGroup</ref></type>
        <definition>FieldGroup CMLibs::Zinc::Fieldmodule::createFieldGroup</definition>
        <argsstring>()</argsstring>
        <name>createFieldGroup</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a group field which can contain an arbitrary set of subregions or region subobjects, and works as a boolean-valued field returning 1 on domains in the group, 0 otherwise.</para>
<para><simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="817" column="19" bodyfile="auto_comments_output/fieldgroup.hpp" bodystart="382" bodyend="386"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a7b718f7050312269a273782a99819dfa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImage" kindref="compound">FieldImage</ref></type>
        <definition>FieldImage CMLibs::Zinc::Fieldmodule::createFieldImage</definition>
        <argsstring>()</argsstring>
        <name>createFieldImage</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a new image field. The new field has no image data; this must be set by calling image field specific methods, e.g. read(). The new field is given a default domain field which one can get (or set) with image field functions. To evaluate the image field you will need to set values of the domain field to texture coordinate locations. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1FieldImage_1a3d8679279b6e9375ba95a0866b9c230e" kindref="member">FieldImage::read</ref></para>
</simplesect>
<simplesect kind="return"><para>Handle to new image field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="829" column="19" bodyfile="auto_comments_output/fieldimage.hpp" bodystart="677" bodyend="681"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5cb3ffcbf313b413c60ec8d2967e837a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImage" kindref="compound">FieldImage</ref></type>
        <definition>FieldImage CMLibs::Zinc::Fieldmodule::createFieldImageFromSource</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldImageFromSource</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a new image field whose image data is sampled from the source field. The source field is typically an image or image-processing field, and its dimension, native resolution and domain field are used as defaults for the new field, or may be changed via image field functions. Non-image source fields give an initial resolution of 1 texel in each image dimension. Texture format will depend on the number of components of the source field: 1 component field creates a LUMINANCE image 2 component field creates a LUMINANCE_ALPHA image 3 component field creates an RGB image 4 component field creates an RGBA image</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source field providing image pixel values. Must be image-based with up to 4 components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new image field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="848" column="19" bodyfile="auto_comments_output/fieldimage.hpp" bodystart="683" bodyend="687"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1af1d08671de57225c65ff3b723542d68f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAnd" kindref="compound">FieldAnd</ref></type>
        <definition>FieldAnd CMLibs::Zinc::Fieldmodule::createFieldAnd</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldAnd</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of source_field_one AND source_field_two is non-zero, 0 otherwise. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="859" column="17" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="241" bodyend="245"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a38a8f0832dcd9610fe1483e1b31aeb7e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldEqualTo" kindref="compound">FieldEqualTo</ref></type>
        <definition>FieldEqualTo CMLibs::Zinc::Fieldmodule::createFieldEqualTo</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldEqualTo</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of source_field_one EQUALS that component of source_field_two, 0 otherwise. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="870" column="21" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="247" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa365e80411c3f822a90d9b70c138a376" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldGreaterThan" kindref="compound">FieldGreaterThan</ref></type>
        <definition>FieldGreaterThan CMLibs::Zinc::Fieldmodule::createFieldGreaterThan</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldGreaterThan</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of source_field_one is greater than the component value in source_field_two. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="881" column="25" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="253" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9644120a24b43b9cb8bab38275b4e974" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldIsDefined" kindref="compound">FieldIsDefined</ref></type>
        <definition>FieldIsDefined CMLibs::Zinc::Fieldmodule::createFieldIsDefined</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldIsDefined</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning 1 (true) at locations where the source field is defined and 0 (false) elsewhere.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to check whether defined at location. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="890" column="23" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="259" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a72476a7de9644f80bd770de56215750c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldLessThan" kindref="compound">FieldLessThan</ref></type>
        <definition>FieldLessThan CMLibs::Zinc::Fieldmodule::createFieldLessThan</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldLessThan</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of source_field_one is less than the component value in source_field_two. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="901" column="22" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="264" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae7cfd30ee552986e8b308b1796234c8d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldOr" kindref="compound">FieldOr</ref></type>
        <definition>FieldOr CMLibs::Zinc::Fieldmodule::createFieldOr</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldOr</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of source_field_one OR source_field_two is non-zero, 0 otherwise. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="912" column="16" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="270" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a29dcfae8dabd2ca8758bdb762ae41609" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNot" kindref="compound">FieldNot</ref></type>
        <definition>FieldNot CMLibs::Zinc::Fieldmodule::createFieldNot</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldNot</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of the source_field is zero, 0 otherwise; effectively a component-wise logical not operator. Returned field has same number of components as source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The source field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="922" column="17" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="276" bodyend="279"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9e05215afebd04b999604d2d9c143e1c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldXor" kindref="compound">FieldXor</ref></type>
        <definition>FieldXor CMLibs::Zinc::Fieldmodule::createFieldXor</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldXor</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose component values are 1 if that component of source_field_one OR source_field_two is non-zero (but not both), 0 otherwise. Automatic scalar broadcast will apply, see field.h.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="933" column="17" bodyfile="auto_comments_output/fieldlogicaloperators.hpp" bodystart="281" bodyend="285"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae29b75cde4912743ac5858d621780cd6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldDeterminant" kindref="compound">FieldDeterminant</ref></type>
        <definition>FieldDeterminant CMLibs::Zinc::Fieldmodule::createFieldDeterminant</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldDeterminant</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the scalar real determinant of a square matrix source field. Only supports up to 3x3 matrix.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying square matrix up to 3x3. May only have 1, 4 or 9 components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="943" column="25" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="247" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a07aecd96619d42266caf4ad67cf097e0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldEigenvalues" kindref="compound">FieldEigenvalues</ref></type>
        <definition>FieldEigenvalues CMLibs::Zinc::Fieldmodule::createFieldEigenvalues</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldEigenvalues</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the N eigenvalues of symmetric N*N component source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>N*N component square symmetric matrix field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="952" column="25" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="258" bodyend="262"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a266342c356de4062a5c2a67b6a70da69" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldEigenvectors" kindref="compound">FieldEigenvectors</ref></type>
        <definition>FieldEigenvectors CMLibs::Zinc::Fieldmodule::createFieldEigenvectors</definition>
        <argsstring>(const Field &amp;eigenvaluesField)</argsstring>
        <name>createFieldEigenvectors</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>eigenvaluesField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the N, N-dimensional eigenvectors computed with the source eigenvalues field. Sets the number of components equal to N*N, where N is the number of components in the &lt;eigenvalues_field&gt;.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>eigenvaluesField</parametername>
</parameternamelist>
<parameterdescription>
<para>Eigenvalues type field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="962" column="26" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="264" bodyend="268"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1acf317ad81f665b2de4844a04cf94dbd0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldMatrixInvert" kindref="compound">FieldMatrixInvert</ref></type>
        <definition>FieldMatrixInvert CMLibs::Zinc::Fieldmodule::createFieldMatrixInvert</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldMatrixInvert</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the inverse of N*N symmetric matrix valued source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>N*N component square symmetric matrix field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="971" column="26" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="270" bodyend="274"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1acf26d84404910091d9e790cb3d73ddab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldMatrixMultiply" kindref="compound">FieldMatrixMultiply</ref></type>
        <definition>FieldMatrixMultiply CMLibs::Zinc::Fieldmodule::createFieldMatrixMultiply</definition>
        <argsstring>(int numberOfRows, const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldMatrixMultiply</name>
        <param>
          <type>int</type>
          <declname>numberOfRows</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the values resulting from matrix multiplication &lt;source_field1&gt; x &lt;source_field2&gt;, with &lt;number_of_rows&gt; rows in both &lt;source_field1&gt; and the result. From the &lt;number_of_rows&gt; the columns in &lt;source_field1&gt;, rows in &lt;source_field2&gt; and then columns in &lt;source_field2&gt; are implied and checked.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>numberOfRows</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows N in source_field1 and result. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>N rows * M columns component matrix field 1. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>M rows * P columns component matrix field 2. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field with N*P components, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="985" column="28" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="281" bodyend="287"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac544b6facdab4a83abb6278d857521ff" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldProjection" kindref="compound">FieldProjection</ref></type>
        <definition>FieldProjection CMLibs::Zinc::Fieldmodule::createFieldProjection</definition>
        <argsstring>(const Field &amp;sourceField, const Field &amp;projectionMatrixField)</argsstring>
        <name>createFieldProjection</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>projectionMatrixField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a projection field returning the result of a matrix multiplication with perspective division on the source field vector. The source_field vector is expanded to a homogeneous coordinate by appending a component of value 1, which is multiplied by the projection_matrix_field, and the extra calculated value resulting from the unit component is used to divide through each of the other components to give a perspective projection in the resulting field. The projection_matrix_field must have have a multiple of (source_field-&gt;number_of_components + 1) components forming a matrix with that many columns and the resulting (number_of_components + 1) rows. The first values in the projection_matrix are across the first row, followed by the next row and so on. Hence a 4x4 matrix transforms a 3-component vector to a 3-component vector: [x&apos;] = [m1 m2 m3 m4 ][x] [y&apos;] = [m5 m6 m7 m8 ][y] [z&apos;] = [m9 m10 m11 m12][z] [h&apos;] = [m13 m14 m15 m16][1] The resulting field returns 3 components [x&apos;/h&apos;, y&apos;/h&apos;, z&apos;/h&apos;]</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source vector field to project. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>projectionMatrixField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying projection matrix. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1011" column="24" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="289" bodyend="294"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1adb7e848f5f1a17add234aea2624790b3" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldTranspose" kindref="compound">FieldTranspose</ref></type>
        <definition>FieldTranspose CMLibs::Zinc::Fieldmodule::createFieldTranspose</definition>
        <argsstring>(int sourceNumberOfRows, const Field &amp;sourceField)</argsstring>
        <name>createFieldTranspose</name>
        <param>
          <type>int</type>
          <declname>sourceNumberOfRows</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the transpose of N*M matrix source_field. The source_number_of_rows is specified; source_number_of_columns is computed as source_field-&gt;number_of_components / &lt;source_number_of_rows&gt;; this division must have no remainder.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceNumberOfRows</parametername>
</parameternamelist>
<parameterdescription>
<para>Number of rows N in source_field. Must be a factor of its number of components. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>N rows * M columns component matrix field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field with M*N matrix components transposed, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1025" column="23" bodyfile="auto_comments_output/fieldmatrixoperators.hpp" bodystart="301" bodyend="307"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a32320f95eb71c9b4498d072fe6f96ace" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldMeshIntegral" kindref="compound">FieldMeshIntegral</ref></type>
        <definition>FieldMeshIntegral CMLibs::Zinc::Fieldmodule::createFieldMeshIntegral</definition>
        <argsstring>(const Field &amp;integrandField, const Field &amp;coordinateField, const Mesh &amp;mesh)</argsstring>
        <name>createFieldMeshIntegral</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>integrandField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Mesh" kindref="compound">Mesh</ref> &amp;</type>
          <declname>mesh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which calculates the numerical integral over the mesh of integrand.dV for volume in 3-D, dA for area in 2-D, dL for length in 1-D. Returned field has same number of components as the integrand field, with each component integrated separately. By default, the integral is calculated by 1-point Gaussian quadrature, sufficient only for linear interpolation. Separate methods are available to set the numbers of quadrature points. Note: uses absolute value of dV/dA/dL so works with right- or left- handed element local coordinate systems. However, cannot handle elements that are partly or completely inverted from expected handedness. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1FieldMeshIntegral_1acd67cff384f6433de119a94167b22dc8" kindref="member">FieldMeshIntegral::setNumbersOfPoints</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>integrandField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to integrate. An integrand of constant value 1 gives the volume/area/length of the mesh. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying coordinates; must have at least as many components as the mesh, up to a maximum of 3. It is up to the user to supply a field giving values in a Rectangular Cartesian coordinate system, using a coordinate transformation field conversion if needed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mesh</parametername>
</parameternamelist>
<parameterdescription>
<para>The mesh to integrate over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1049" column="26" bodyfile="auto_comments_output/fieldmeshoperators.hpp" bodystart="196" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aaf32771ad5b5ac242b2163dcb03c759c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldMeshIntegralSquares" kindref="compound">FieldMeshIntegralSquares</ref></type>
        <definition>FieldMeshIntegralSquares CMLibs::Zinc::Fieldmodule::createFieldMeshIntegralSquares</definition>
        <argsstring>(const Field &amp;integrandField, const Field &amp;coordinateField, const Mesh &amp;mesh)</argsstring>
        <name>createFieldMeshIntegralSquares</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>integrandField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Mesh" kindref="compound">Mesh</ref> &amp;</type>
          <declname>mesh</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a specialisation of the mesh integral field that integrates the squares of the components of the integrand field. Note that the volume/area/length and weights are not squared in the integral. This field type supports least-squares optimisation by giving individual terms being squared and summed. This field can be cast to a mesh integral field to set type-specific attributes. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a32320f95eb71c9b4498d072fe6f96ace" kindref="member">Fieldmodule::createFieldMeshIntegral</ref> </para>
</simplesect>
<simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1FieldMeshIntegral" kindref="compound">FieldMeshIntegral</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>integrandField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to integrate the square of. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying coordinates; must have at least as many components as the mesh, up to a maximum of 3. It is up to the user to supply a field giving values in a Rectangular Cartesian coordinate system, using a coordinate transformation field conversion if needed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>mesh</parametername>
</parameternamelist>
<parameterdescription>
<para>The mesh to integrate over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1071" column="33" bodyfile="auto_comments_output/fieldmeshoperators.hpp" bodystart="209" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a3dff60d1cb93cc0e485a8ea4cf8ef487" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodesetSum" kindref="compound">FieldNodesetSum</ref></type>
        <definition>FieldNodesetSum CMLibs::Zinc::Fieldmodule::createFieldNodesetSum</definition>
        <argsstring>(const Field &amp;sourceField, const Nodeset &amp;nodeset)</argsstring>
        <name>createFieldNodesetSum</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref> &amp;</type>
          <declname>nodeset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which computes the sum of each source field component over all nodes in the nodeset for which it is defined. Returned field has same number of components as the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to sum. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeset</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of nodes to sum field over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1083" column="24" bodyfile="auto_comments_output/fieldnodesetoperators.hpp" bodystart="282" bodyend="286"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a52ad927ca7b2e3cd2a04188f850f7074" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodesetMean" kindref="compound">FieldNodesetMean</ref></type>
        <definition>FieldNodesetMean CMLibs::Zinc::Fieldmodule::createFieldNodesetMean</definition>
        <argsstring>(const Field &amp;sourceField, const Nodeset &amp;nodeset)</argsstring>
        <name>createFieldNodesetMean</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref> &amp;</type>
          <declname>nodeset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which computes the mean of each source field component over all nodes in the nodeset for which it is defined. Returned field has same number of components as the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to obtain mean component values for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeset</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of nodes to obtain mean over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1094" column="25" bodyfile="auto_comments_output/fieldnodesetoperators.hpp" bodystart="288" bodyend="292"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a22b537fd76d1aafd3033f8c4b6acdf5a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodesetSumSquares" kindref="compound">FieldNodesetSumSquares</ref></type>
        <definition>FieldNodesetSumSquares CMLibs::Zinc::Fieldmodule::createFieldNodesetSumSquares</definition>
        <argsstring>(const Field &amp;sourceField, const Nodeset &amp;nodeset)</argsstring>
        <name>createFieldNodesetSumSquares</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref> &amp;</type>
          <declname>nodeset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which computes the sum of the squares of each source field component over all nodes in the nodeset for which it is defined. Returned field has same number of components as the source field. This field type supports least-squares optimisation by giving individual terms being squared and summed. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Optimisation_1ac38c6655a7f9a7cc8a3646831a3e8712" kindref="member">Optimisation::addObjectiveField</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to sum squared component values of. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeset</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of nodes to sum field over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1108" column="31" bodyfile="auto_comments_output/fieldnodesetoperators.hpp" bodystart="294" bodyend="299"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ab8224c27851cec760699fb08e2885862" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodesetMeanSquares" kindref="compound">FieldNodesetMeanSquares</ref></type>
        <definition>FieldNodesetMeanSquares CMLibs::Zinc::Fieldmodule::createFieldNodesetMeanSquares</definition>
        <argsstring>(const Field &amp;sourceField, const Nodeset &amp;nodeset)</argsstring>
        <name>createFieldNodesetMeanSquares</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref> &amp;</type>
          <declname>nodeset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which computes the mean of the squares of each source field component over all nodes in the nodeset for which it is defined. Returned field has same number of components as the source field. This field type supports least-squares optimisation by giving individual terms being squared and summed, each divided by the square root of the number of terms. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Optimisation_1ac38c6655a7f9a7cc8a3646831a3e8712" kindref="member">Optimisation::addObjectiveField</ref></para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to obtain mean squared component values for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeset</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of nodes to obtain mean over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1123" column="32" bodyfile="auto_comments_output/fieldnodesetoperators.hpp" bodystart="301" bodyend="306"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a7910e69c660bdd2445e41b694877a7ae" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodesetMinimum" kindref="compound">FieldNodesetMinimum</ref></type>
        <definition>FieldNodesetMinimum CMLibs::Zinc::Fieldmodule::createFieldNodesetMinimum</definition>
        <argsstring>(const Field &amp;sourceField, const Nodeset &amp;nodeset)</argsstring>
        <name>createFieldNodesetMinimum</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref> &amp;</type>
          <declname>nodeset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which computes the minimum of each source field component over all nodes in the nodeset for which it is defined. Returned field has same number of components as the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to obtain minimum values for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeset</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of nodes to obtain minimum over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1134" column="28" bodyfile="auto_comments_output/fieldnodesetoperators.hpp" bodystart="308" bodyend="313"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1ae050a95887601ae11eb7059f707ddc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodesetMaximum" kindref="compound">FieldNodesetMaximum</ref></type>
        <definition>FieldNodesetMaximum CMLibs::Zinc::Fieldmodule::createFieldNodesetMaximum</definition>
        <argsstring>(const Field &amp;sourceField, const Nodeset &amp;nodeset)</argsstring>
        <name>createFieldNodesetMaximum</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Nodeset" kindref="compound">Nodeset</ref> &amp;</type>
          <declname>nodeset</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which computes the maximum of each source field component over all nodes in the nodeset for which it is defined. Returned field has same number of components as the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to obtain maximum values for. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>nodeset</parametername>
</parameternamelist>
<parameterdescription>
<para>The set of nodes to obtain maximum over. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1145" column="28" bodyfile="auto_comments_output/fieldnodesetoperators.hpp" bodystart="315" bodyend="320"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a19279722d6969aebd174185d89670266" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldTimeLookup" kindref="compound">FieldTimeLookup</ref></type>
        <definition>FieldTimeLookup CMLibs::Zinc::Fieldmodule::createFieldTimeLookup</definition>
        <argsstring>(const Field &amp;sourceField, const Field &amp;timeField)</argsstring>
        <name>createFieldTimeLookup</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>timeField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose value equals the source_field evaluated at the time given by time_field, overriding any time prescribed for field evaluation.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to evaluate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> providing time value to evaluate at. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1155" column="24" bodyfile="auto_comments_output/fieldtime.hpp" bodystart="66" bodyend="70"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a3e7c1978bf49ddb6f6ac45a69d782275" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldTimeValue" kindref="compound">FieldTimeValue</ref></type>
        <definition>FieldTimeValue CMLibs::Zinc::Fieldmodule::createFieldTimeValue</definition>
        <argsstring>(const Timekeeper &amp;timeKeeper)</argsstring>
        <name>createFieldTimeValue</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Timekeeper" kindref="compound">Timekeeper</ref> &amp;</type>
          <declname>timeKeeper</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which returns the current time from the supplied time keeper.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>timeKeeper</parametername>
</parameternamelist>
<parameterdescription>
<para>cmzn_timekeeper object. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1163" column="23" bodyfile="auto_comments_output/fieldtime.hpp" bodystart="72" bodyend="75"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aab696e0517006618c030959228cb7b1e" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldDerivative" kindref="compound">FieldDerivative</ref></type>
        <definition>FieldDerivative CMLibs::Zinc::Fieldmodule::createFieldDerivative</definition>
        <argsstring>(const Field &amp;sourceField, int xi_index)</argsstring>
        <name>createFieldDerivative</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>int</type>
          <declname>xi_index</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the derivative of the source field with respect to the chosen element xi coordinate index as its primary value. The xi index is relative to the element/face/line it is evaluated on, not the top-level element. Returned field has same number of components as the source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source field to get derivative number. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>xi_index</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Element" kindref="compound">Element</ref> coordinate system index for derivative, from 1 to element dimension. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1176" column="24" bodyfile="auto_comments_output/fieldderivatives.hpp" bodystart="160" bodyend="164"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2871f2233f16e053ee2643bce5cd7c6d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldCurl" kindref="compound">FieldCurl</ref></type>
        <definition>FieldCurl CMLibs::Zinc::Fieldmodule::createFieldCurl</definition>
        <argsstring>(const Field &amp;vectorField, const Field &amp;coordinateField)</argsstring>
        <name>createFieldCurl</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>vectorField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the curl of vector_field at location given by coordinate_field. All fields including return field have 3 components.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vectorField</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector field from which curl is evaluated. Must have rectangular cartesian coordinate system. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying location. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1187" column="18" bodyfile="auto_comments_output/fieldderivatives.hpp" bodystart="171" bodyend="174"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aabc1bd62ee94c635a45d1021a7d44fe4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldDivergence" kindref="compound">FieldDivergence</ref></type>
        <definition>FieldDivergence CMLibs::Zinc::Fieldmodule::createFieldDivergence</definition>
        <argsstring>(const Field &amp;vectorField, const Field &amp;coordinateField)</argsstring>
        <name>createFieldDivergence</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>vectorField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a scalar field returning the divergence of vector field within coordinate field. The number of components of &lt;vector_field&gt; and &lt;coordinate_field&gt; must be the same and less than or equal to 3.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>vectorField</parametername>
</parameternamelist>
<parameterdescription>
<para>Vector field from which divergence is evaluated. Must have rectangular cartesian coordinate system. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying location. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1200" column="24" bodyfile="auto_comments_output/fieldderivatives.hpp" bodystart="176" bodyend="179"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a132d78cade8575b69000fb8f8bbe5a9a" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldGradient" kindref="compound">FieldGradient</ref></type>
        <definition>FieldGradient CMLibs::Zinc::Fieldmodule::createFieldGradient</definition>
        <argsstring>(const Field &amp;sourceField, const Field &amp;coordinateField)</argsstring>
        <name>createFieldGradient</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>coordinateField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the gradient of a source field with respect to a given coordinate field. Evaluation is only possible in elements of dimension equal or less than the number of components in the coordinate field. If the element dimension is lower, ficticious orthogonal xi axes are defined so that the derivative of coordinates w.r.t. xi is square and hence invertable. The number of components of the new field is the product of the numbers of components in the source and coordinate fields. If the source field has multiple components, all the derivatives of its first component w.r.t. the coordinate components are given first, followed by the second component, etc. Hence, this function can return the standard gradient of a scalar source field, and the deformation gradient if a deformed coordinate field is passed as the source field. The gradient can also be calculated at nodes, albeit approximately using a finite difference approach by perturbing the coordinate field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to calculate gradient of. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>coordinateField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> supplying coordinate location over which the source field is expected to vary, with up to 3 real components. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1224" column="22" bodyfile="auto_comments_output/fieldderivatives.hpp" bodystart="181" bodyend="185"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1a5e40429b3bf4698eb8d01dd6f3fd40" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldSin" kindref="compound">FieldSin</ref></type>
        <definition>FieldSin CMLibs::Zinc::Fieldmodule::createFieldSin</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldSin</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are the sine value (using radians) of the components of the source_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1233" column="17" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="187" bodyend="190"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a81786dcaf9213220cf88de8b73c06f47" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldCos" kindref="compound">FieldCos</ref></type>
        <definition>FieldCos CMLibs::Zinc::Fieldmodule::createFieldCos</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldCos</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are the cosine value (using radians) of the components of the source_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Input field (components in radians) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1242" column="17" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="192" bodyend="195"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1acdb60288bae29974e227b3a090883313" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldTan" kindref="compound">FieldTan</ref></type>
        <definition>FieldTan CMLibs::Zinc::Fieldmodule::createFieldTan</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldTan</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are the trigonometric tangent value (using radians) of the components of the source_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Input field (components in radians) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1251" column="17" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="197" bodyend="200"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a706b25d7616a3da7a880fc9fae5cf017" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAsin" kindref="compound">FieldAsin</ref></type>
        <definition>FieldAsin CMLibs::Zinc::Fieldmodule::createFieldAsin</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldAsin</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are the arcsine value (using radians) of the components of the source_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Input field (components in radians) </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1260" column="18" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="202" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a471c4beb0d9cf5eec3b34cfa7ce330ca" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAcos" kindref="compound">FieldAcos</ref></type>
        <definition>FieldAcos CMLibs::Zinc::Fieldmodule::createFieldAcos</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldAcos</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are the arccosine value (using radians) of the components of the source_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1269" column="18" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="207" bodyend="210"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa12315c93a417ab2dc502dac6da6e8fe" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAtan" kindref="compound">FieldAtan</ref></type>
        <definition>FieldAtan CMLibs::Zinc::Fieldmodule::createFieldAtan</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldAtan</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are the arctangent value (using radians) of the components of the source_field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1278" column="18" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="212" bodyend="215"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1adaf3553c511285220e140751f1347be4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldAtan2" kindref="compound">FieldAtan2</ref></type>
        <definition>FieldAtan2 CMLibs::Zinc::Fieldmodule::createFieldAtan2</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldAtan2</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field where the components are calculated using the atan2 c function, so that the angle returned (in radians) is the angle between a positive x axis in a plane and the vector (x,y) where x is the source_field_one component and y is the source_field_two component.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First input field </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second input field </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1290" column="19" bodyfile="auto_comments_output/fieldtrigonometry.hpp" bodystart="217" bodyend="221"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1acf18b75bfc67eb00720b3742bc1163f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldCrossProduct" kindref="compound">FieldCrossProduct</ref></type>
        <definition>FieldCrossProduct CMLibs::Zinc::Fieldmodule::createFieldCrossProduct</definition>
        <argsstring>(int fieldsCount, const Field *sourceFields)</argsstring>
        <name>createFieldCrossProduct</name>
        <param>
          <type>int</type>
          <declname>fieldsCount</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> *</type>
          <declname>sourceFields</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a vector field which is the cross product of the source_fields. The number of source fields determines the number of components i.e. dimension of the source_fields and the result. Allowable numbers: 1 : single 2-D vector source field. Returns orthogonal vector in 2-D plane given by 90 degree rotation anticlockwise. 2 : two 3-D vector source fields. Returns familiar 3-D cross product vector orthogonal to both source vectors in a right hand sense, whose magnitude is the area of the parallelogram formed by the source vectors on 2 sides. 3 : cross product of three 4-D vector source fields.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>fieldsCount</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the source_fields array, one less than the dimension i.e. number of components of each source_field and the result. Only 1, 2 and 3 fields i.e. 2-D, 3-D and 4-D are supported. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceFields</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of fields with number of components equal to the dimension i.e. one more than the number_of_source_fields. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1310" column="26" bodyfile="auto_comments_output/fieldvectoroperators.hpp" bodystart="146" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2cc2ab83ac93f519049cefb1a3d0aefd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldCrossProduct" kindref="compound">FieldCrossProduct</ref></type>
        <definition>FieldCrossProduct CMLibs::Zinc::Fieldmodule::createFieldCrossProduct</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldCrossProduct</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a vector field which is the cross product of the source_fields. The number of source fields determines the number of components i.e. dimension of the source_fields and the result. Allowable numbers: 1 : single 2-D vector source field. Returns orthogonal vector in 2-D plane given by 90 degree rotation anticlockwise. 2 : two 3-D vector source fields. Returns familiar 3-D cross product vector orthogonal to both source vectors in a right hand sense, whose magnitude is the area of the parallelogram formed by the source vectors on 2 sides. 3 : cross product of three 4-D vector source fields.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the source_fields array, one less than the dimension i.e. number of components of each source_field and the result. Only 1, 2 and 3 fields i.e. 2-D, 3-D and 4-D are supported. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of fields with number of components equal to the dimension i.e. one more than the number_of_source_fields. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1330" column="26" bodyfile="auto_comments_output/fieldvectoroperators.hpp" bodystart="162" bodyend="166"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a13bbdbbcbbc60e180e69a173f2b20704" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldDotProduct" kindref="compound">FieldDotProduct</ref></type>
        <definition>FieldDotProduct CMLibs::Zinc::Fieldmodule::createFieldDotProduct</definition>
        <argsstring>(const Field &amp;sourceField1, const Field &amp;sourceField2)</argsstring>
        <name>createFieldDotProduct</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField1</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField2</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a scalar field whose value is the dot product of the two supplied source fields, which must have equal numbers of components.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField1</parametername>
</parameternamelist>
<parameterdescription>
<para>First source field. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>sourceField2</parametername>
</parameternamelist>
<parameterdescription>
<para>Second source field. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1340" column="24" bodyfile="auto_comments_output/fieldvectoroperators.hpp" bodystart="168" bodyend="172"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa9b65e612fd64fd1b0ef1ade93f6c806" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldMagnitude" kindref="compound">FieldMagnitude</ref></type>
        <definition>FieldMagnitude CMLibs::Zinc::Fieldmodule::createFieldMagnitude</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldMagnitude</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a scalar field returning the magnitude of the vector source field.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source field to normalise. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1348" column="23" bodyfile="auto_comments_output/fieldvectoroperators.hpp" bodystart="174" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a8efbf42002909f9fd9139fd6aaabec99" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNodeLookup" kindref="compound">FieldNodeLookup</ref></type>
        <definition>FieldNodeLookup CMLibs::Zinc::Fieldmodule::createFieldNodeLookup</definition>
        <argsstring>(const Field &amp;sourceField, const Node &amp;lookupNode)</argsstring>
        <name>createFieldNodeLookup</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Node" kindref="compound">Node</ref> &amp;</type>
          <declname>lookupNode</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose value equals source field calculated at the lookup node instead of the domain location requested.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para><ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> to evaluate. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lookupNode</parametername>
</parameternamelist>
<parameterdescription>
<para>The node to evaluate the source field at. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1358" column="24" bodyfile="auto_comments_output/fieldfiniteelement.hpp" bodystart="732" bodyend="737"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a733d6dbe54eca2464b7d70453e060525" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldNormalise" kindref="compound">FieldNormalise</ref></type>
        <definition>FieldNormalise CMLibs::Zinc::Fieldmodule::createFieldNormalise</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldNormalise</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning the values of source vector field normalised to unit length.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>Source field to normalise. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1367" column="23" bodyfile="auto_comments_output/fieldvectoroperators.hpp" bodystart="179" bodyend="182"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a385e8a5dbcdfab97e8d3d0e5ced5e893" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterBinaryDilate" kindref="compound">FieldImagefilterBinaryDilate</ref></type>
        <definition>FieldImagefilterBinaryDilate CMLibs::Zinc::Fieldmodule::createFieldImagefilterBinaryDilate</definition>
        <argsstring>(const Field &amp;sourceField, int radius, double dilate_value)</argsstring>
        <name>createFieldImagefilterBinaryDilate</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>int</type>
          <declname>radius</declname>
        </param>
        <param>
          <type>double</type>
          <declname>dilate_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK binary dilate image filter on scalar source field image. Sets number of components to same number as &lt;source_field&gt;. The &lt;radius&gt; and &lt;dilate_value&gt; specify the radius of pixels to use for dilation and what pixel value to use for dilation <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1376" column="37" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="700" bodyend="706"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a09d31fb137cea8afdf072463a19ba4d2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterBinaryErode" kindref="compound">FieldImagefilterBinaryErode</ref></type>
        <definition>FieldImagefilterBinaryErode CMLibs::Zinc::Fieldmodule::createFieldImagefilterBinaryErode</definition>
        <argsstring>(const Field &amp;sourceField, int radius, double erode_value)</argsstring>
        <name>createFieldImagefilterBinaryErode</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>int</type>
          <declname>radius</declname>
        </param>
        <param>
          <type>double</type>
          <declname>erode_value</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK binary erode image filter on scalar source field image. Sets number of components to same number as &lt;source_field&gt;. The &lt;radius&gt; and &lt;erode_value&gt; specify the radius of pixels to use for dilation and what pixel value to use for dilation <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1386" column="36" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="709" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad3b5e7896f3f4a738ed7ab89e8a382d4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterBinaryThreshold" kindref="compound">FieldImagefilterBinaryThreshold</ref></type>
        <definition>FieldImagefilterBinaryThreshold CMLibs::Zinc::Fieldmodule::createFieldImagefilterBinaryThreshold</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldImagefilterBinaryThreshold</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field which applies an ITK binary threshold image filter on source. The newly created field consists of binary values (either 0 or 1) which are determined by applying the threshold range to the source field. Input values with an intensity range between lower_threshold and the upper_threshold are set to 1, the rest are set to 0.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field to be filtered </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1399" column="40" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="718" bodyend="722"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a7381f7c891c2c6344284431e9fb9867b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterCannyEdgeDetection" kindref="compound">FieldImagefilterCannyEdgeDetection</ref></type>
        <definition>FieldImagefilterCannyEdgeDetection CMLibs::Zinc::Fieldmodule::createFieldImagefilterCannyEdgeDetection</definition>
        <argsstring>(const Field &amp;sourceField, double variance, double maximumError, double upperThreshold, double lowerThreshold)</argsstring>
        <name>createFieldImagefilterCannyEdgeDetection</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>double</type>
          <declname>variance</declname>
        </param>
        <param>
          <type>double</type>
          <declname>maximumError</declname>
        </param>
        <param>
          <type>double</type>
          <declname>upperThreshold</declname>
        </param>
        <param>
          <type>double</type>
          <declname>lowerThreshold</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field returning result of ITK canny edge detection filter on the source field image. Sets number of components to same number as source field. <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1406" column="43" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="730" bodyend="737"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2e9d6a41bb579246e7487e1125ba9bd8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterConnectedThreshold" kindref="compound">FieldImagefilterConnectedThreshold</ref></type>
        <definition>FieldImagefilterConnectedThreshold CMLibs::Zinc::Fieldmodule::createFieldImagefilterConnectedThreshold</definition>
        <argsstring>(const Field &amp;sourceField, double lowerThreshold, double upperThreshold, double replaceValue, int dimension, int seedPointsCount, const double *seedPoints)</argsstring>
        <name>createFieldImagefilterConnectedThreshold</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>double</type>
          <declname>lowerThreshold</declname>
        </param>
        <param>
          <type>double</type>
          <declname>upperThreshold</declname>
        </param>
        <param>
          <type>double</type>
          <declname>replaceValue</declname>
        </param>
        <param>
          <type>int</type>
          <declname>dimension</declname>
        </param>
        <param>
          <type>int</type>
          <declname>seedPointsCount</declname>
        </param>
        <param>
          <type>const double *</type>
          <declname>seedPoints</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK connected threshold image filter on scalar source field image. Sets number of components to same number as source field. <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1414" column="43" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="740" bodyend="747"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae4a13ec76648cf9f6d43cb0a8d004e78" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterCurvatureAnisotropicDiffusion" kindref="compound">FieldImagefilterCurvatureAnisotropicDiffusion</ref></type>
        <definition>FieldImagefilterCurvatureAnisotropicDiffusion CMLibs::Zinc::Fieldmodule::createFieldImagefilterCurvatureAnisotropicDiffusion</definition>
        <argsstring>(const Field &amp;sourceField, double timeStep, double conductance, int numIterations)</argsstring>
        <name>createFieldImagefilterCurvatureAnisotropicDiffusion</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>double</type>
          <declname>timeStep</declname>
        </param>
        <param>
          <type>double</type>
          <declname>conductance</declname>
        </param>
        <param>
          <type>int</type>
          <declname>numIterations</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK curvature anisotropic diffusion image filter on scalar source field image. Sets number of components to same number as &lt;source_field&gt;.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field to be filtered </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>timeStep</parametername>
</parameternamelist>
<parameterdescription>
<para>The time step </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>conductance</parametername>
</parameternamelist>
<parameterdescription>
<para>The conductance </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>numIterations</parametername>
</parameternamelist>
<parameterdescription>
<para>The number of iterations to be performed </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1429" column="54" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="750" bodyend="756"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2ed56ec7ab375c886bd2bf398027faf7" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterDiscreteGaussian" kindref="compound">FieldImagefilterDiscreteGaussian</ref></type>
        <definition>FieldImagefilterDiscreteGaussian CMLibs::Zinc::Fieldmodule::createFieldImagefilterDiscreteGaussian</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldImagefilterDiscreteGaussian</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field applying the ITK discrete gaussian image filter to the source field. This means that each pixel value in the new field is based on a weighted average of the pixel and the surrounding pixel values from the source field. Pixels further away are given a lower weighting. Increasing the variance increases the width of the gaussian distribution used and hence the number of pixels used to calculate the weighted average. This smooths the image more. A limit is set on the max_kernel_width used to approximate the guassian to ensure the calculation completes.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field to be filtered </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1445" column="41" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="759" bodyend="763"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae0e76bb67f346c9dd7339092f4bef06b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterHistogram" kindref="compound">FieldImagefilterHistogram</ref></type>
        <definition>FieldImagefilterHistogram CMLibs::Zinc::Fieldmodule::createFieldImagefilterHistogram</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldImagefilterHistogram</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK histogram image filter on source field image. If neither histogramMinimum or histogramMaximum are specified then the minimums and maximums are calculated based on the minimum and maximum values in the input image.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field to generate the histogram for. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1455" column="34" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="780" bodyend="784"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1abff28dc08f25a9f4b368e0b17e069346" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterMean" kindref="compound">FieldImagefilterMean</ref></type>
        <definition>FieldImagefilterMean CMLibs::Zinc::Fieldmodule::createFieldImagefilterMean</definition>
        <argsstring>(const Field &amp;sourceField, int radiusSizesCount, const int *radiusSizesIn)</argsstring>
        <name>createFieldImagefilterMean</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>int</type>
          <declname>radiusSizesCount</declname>
        </param>
        <param>
          <type>const int *</type>
          <declname>radiusSizesIn</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK mean image filter on source_field image. Sets number of components to same number as &lt;source_field&gt;.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The source field to be processed. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radiusSizesCount</parametername>
</parameternamelist>
<parameterdescription>
<para>The size of the radius sizes array. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>radiusSizesIn</parametername>
</parameternamelist>
<parameterdescription>
<para>Array of radius sizes to use in each image axis. If there are fewer sizes than image dimension the last value is used on subsequent image axes. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1468" column="29" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="800" bodyend="805"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a4f013b172c01e2889ac2e9170775f243" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterGradientMagnitudeRecursiveGaussian" kindref="compound">FieldImagefilterGradientMagnitudeRecursiveGaussian</ref></type>
        <definition>FieldImagefilterGradientMagnitudeRecursiveGaussian CMLibs::Zinc::Fieldmodule::createFieldImagefilterGradientMagnitudeRecursiveGaussian</definition>
        <argsstring>(const Field &amp;sourceField, double sigma)</argsstring>
        <name>createFieldImagefilterGradientMagnitudeRecursiveGaussian</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>double</type>
          <declname>sigma</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK gradient magnitude recursive gaussian image filter on scalar source field image. Sets number of components to same number as &lt;source_field&gt;. <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1478" column="1" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="771" bodyend="777"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1aff8f1c9265cf10825f32cdfa751a19e0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterRescaleIntensity" kindref="compound">FieldImagefilterRescaleIntensity</ref></type>
        <definition>FieldImagefilterRescaleIntensity CMLibs::Zinc::Fieldmodule::createFieldImagefilterRescaleIntensity</definition>
        <argsstring>(const Field &amp;sourceField, double outputMin, double outputMax)</argsstring>
        <name>createFieldImagefilterRescaleIntensity</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>double</type>
          <declname>outputMin</declname>
        </param>
        <param>
          <type>double</type>
          <declname>outputMax</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK rescale intensity image filter on scalar source field image. Sets number of components to same number as source field. <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1486" column="41" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="792" bodyend="798"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a43e5e19417714e3b9d3853f0c38de577" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterSigmoid" kindref="compound">FieldImagefilterSigmoid</ref></type>
        <definition>FieldImagefilterSigmoid CMLibs::Zinc::Fieldmodule::createFieldImagefilterSigmoid</definition>
        <argsstring>(const Field &amp;sourceField, double min, double max, double alpha, double beta)</argsstring>
        <name>createFieldImagefilterSigmoid</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <param>
          <type>double</type>
          <declname>min</declname>
        </param>
        <param>
          <type>double</type>
          <declname>max</declname>
        </param>
        <param>
          <type>double</type>
          <declname>alpha</declname>
        </param>
        <param>
          <type>double</type>
          <declname>beta</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field performing ITK sigmoid image filter on scalar source field image. Sets number of components to same number as &lt;source_field&gt;. <simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1494" column="32" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="808" bodyend="814"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1a921ba7b7d76164dbfa82b1afed349082" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldImagefilterThreshold" kindref="compound">FieldImagefilterThreshold</ref></type>
        <definition>FieldImagefilterThreshold CMLibs::Zinc::Fieldmodule::createFieldImagefilterThreshold</definition>
        <argsstring>(const Field &amp;sourceField)</argsstring>
        <name>createFieldImagefilterThreshold</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Field" kindref="compound">Field</ref> &amp;</type>
          <declname>sourceField</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field applying the ITK threshold image filter to the source field. The newly created field replaces certain values with a specified outside value, based on which threshold mode and the threshold values.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sourceField</parametername>
</parameternamelist>
<parameterdescription>
<para>The field to be filtered </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1505" column="34" bodyfile="auto_comments_output/fieldimageprocessing.hpp" bodystart="817" bodyend="822"/>
      </memberdef>
      <memberdef kind="function" id="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad18d38697f927f0ab0ed25762660f171" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classCMLibs_1_1Zinc_1_1FieldSceneviewerProjection" kindref="compound">FieldSceneviewerProjection</ref></type>
        <definition>FieldSceneviewerProjection CMLibs::Zinc::Fieldmodule::createFieldSceneviewerProjection</definition>
        <argsstring>(const Sceneviewer &amp;sceneviewer, Scenecoordinatesystem fromCoordinateSystem, Scenecoordinatesystem toCoordinateSystem)</argsstring>
        <name>createFieldSceneviewerProjection</name>
        <param>
          <type>const <ref refid="classCMLibs_1_1Zinc_1_1Sceneviewer" kindref="compound">Sceneviewer</ref> &amp;</type>
          <declname>sceneviewer</declname>
        </param>
        <param>
          <type><ref refid="namespaceCMLibs_1_1Zinc_1ad1f76ef76163881124d8c2a946826391" kindref="member">Scenecoordinatesystem</ref></type>
          <declname>fromCoordinateSystem</declname>
        </param>
        <param>
          <type><ref refid="namespaceCMLibs_1_1Zinc_1ad1f76ef76163881124d8c2a946826391" kindref="member">Scenecoordinatesystem</ref></type>
          <declname>toCoordinateSystem</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Creates a field whose values are the 4x4 transformation matrix mapping coordinates between two scene coordinate systems for a scene viewer. The matrix maps homogeneous coordinates (x,y,z,1) to (x&apos;,y&apos;,z&apos;,h&apos;) suitable for passing to a projection field. The values are continuously updated with changes to the scene viewer and become invalid if the scene viewer is destroyed. Note CMZN_SCENECOORDINATESYSTEM_LOCAL gives the local coordinate system of the scene for the owning region of field, which is transformed from world coordinates by the cumulative transformation matrices of all scenes down from the root region of the scene viewer&apos;s scene. <simplesect kind="see"><para><ref refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac544b6facdab4a83abb6278d857521ff" kindref="member">Fieldmodule::createFieldProjection</ref>.</para>
</simplesect>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>sceneviewer</parametername>
</parameternamelist>
<parameterdescription>
<para>Handle to sceneviewer object. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fromCoordinateSystem</parametername>
</parameternamelist>
<parameterdescription>
<para>The input coordinate system for the transformation. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>toCoordinateSystem</parametername>
</parameternamelist>
<parameterdescription>
<para>The output coordinate system for the transformation. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>Handle to new field with 16 components, or NULL/invalid handle on failure. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="auto_comments_output/fieldmodule.hpp" line="1527" column="35" bodyfile="auto_comments_output/fieldsceneviewerprojection.hpp" bodystart="56" bodyend="63"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Container/manager of fields and domains within a region. </para>
    </briefdescription>
    <detaileddescription>
<para>Container/manager of fields and domains within a region.</para>
<para>Note that fieldmodule create field methods documented as supporting &apos;automatic scalar broadcast&apos; for their source field arguments work as follows: if given a mix of scalar and vector source fields, the scalar value is applied to each component of the vector, e.g. the result of ADD(CONSTANT([1 2 3 4], CONSTANT([10]) is [11 12 13 14]. Internally it works by substituing the scalar operand with a concatenate field with the same number of components as the vector operand, but filled with the scalar value. </para>
    </detaileddescription>
    <location file="auto_comments_output/fieldmodule.hpp" line="135" column="1" bodyfile="auto_comments_output/fieldmodule.hpp" bodystart="134" bodyend="1530"/>
    <listofallmembers>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5a5ece70513615b1389587cf1351abff" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>beginChange</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1acc766d868e3821e012a3e87d343f72f0" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createElementbasis</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1afa5a78d8c8ba22510b4f327b23e7195a" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAbs</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a471c4beb0d9cf5eec3b34cfa7ce330ca" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAcos</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1adb0d75da2f36cbb1e753142f196e79d3" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAdd</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1af1d08671de57225c65ff3b723542d68f" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAnd</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae4f27ddaff29135583831224eec64d4d" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldApply</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa5d3836ac0092c6d5147f65b9263e4a5" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldArgumentReal</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a706b25d7616a3da7a880fc9fae5cf017" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAsin</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa12315c93a417ab2dc502dac6da6e8fe" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAtan</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1adaf3553c511285220e140751f1347be4" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldAtan2</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a86b366b0c3487fea69112a1db342ed26" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldcache</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a13e59f1bb2dd5a459d7b32aa845406b3" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldComponent</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac7e484c86476176a8f6dddda1450b0d9" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldComponent</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a484001251e3080b80526500e214fd3cf" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldConcatenate</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac351d583857d1576f81a3dbfc66d8918" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldConstant</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa9154e8ea1fad2d89206201f4c0139e6" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldCoordinateTransformation</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a81786dcaf9213220cf88de8b73c06f47" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldCos</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1acf18b75bfc67eb00720b3742bc1163f1" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldCrossProduct</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2cc2ab83ac93f519049cefb1a3d0aefd" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldCrossProduct</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2871f2233f16e053ee2643bce5cd7c6d" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldCurl</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aab696e0517006618c030959228cb7b1e" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldDerivative</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae29b75cde4912743ac5858d621780cd6" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldDeterminant</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aabc1bd62ee94c635a45d1021a7d44fe4" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldDivergence</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad55ea71f4ccf1ac12aaae7b9813bc02e" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldDivide</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a13bbdbbcbbc60e180e69a173f2b20704" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldDotProduct</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1f0296d5ccf785372e9dcf20325858d1" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldEdgeDiscontinuity</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a07aecd96619d42266caf4ad67cf097e0" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldEigenvalues</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a266342c356de4062a5c2a67b6a70da69" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldEigenvectors</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aad294a32dd7da04a40439f3672c92b88" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldEmbedded</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a38a8f0832dcd9610fe1483e1b31aeb7e" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldEqualTo</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2afd6351d30e89765859f51f68bfbcec" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldExp</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a6831ea6e179a9b95cb26dfa0f5d4dc75" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldFibreAxes</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5d9caf67a46f1229470ece3f05e3a7e1" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldFindMeshLocation</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5ecc267b21519b2be0ee27e7fec3b983" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldFiniteElement</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a132d78cade8575b69000fb8f8bbe5a9a" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldGradient</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa365e80411c3f822a90d9b70c138a376" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldGreaterThan</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ab0193597652fab2717094068651dfdd1" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldGroup</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9e6a92b449cc3ecd9ba0ff01a6eada54" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldIdentity</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a57d403518c146728ef0f53707ea19262" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldIf</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a7b718f7050312269a273782a99819dfa" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImage</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a385e8a5dbcdfab97e8d3d0e5ced5e893" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterBinaryDilate</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a09d31fb137cea8afdf072463a19ba4d2" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterBinaryErode</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad3b5e7896f3f4a738ed7ab89e8a382d4" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterBinaryThreshold</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a7381f7c891c2c6344284431e9fb9867b" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterCannyEdgeDetection</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2e9d6a41bb579246e7487e1125ba9bd8" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterConnectedThreshold</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae4a13ec76648cf9f6d43cb0a8d004e78" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterCurvatureAnisotropicDiffusion</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2ed56ec7ab375c886bd2bf398027faf7" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterDiscreteGaussian</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a4f013b172c01e2889ac2e9170775f243" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterGradientMagnitudeRecursiveGaussian</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae0e76bb67f346c9dd7339092f4bef06b" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterHistogram</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1abff28dc08f25a9f4b368e0b17e069346" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterMean</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aff8f1c9265cf10825f32cdfa751a19e0" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterRescaleIntensity</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a43e5e19417714e3b9d3853f0c38de577" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterSigmoid</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a921ba7b7d76164dbfa82b1afed349082" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImagefilterThreshold</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5cb3ffcbf313b413c60ec8d2967e837a" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldImageFromSource</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9644120a24b43b9cb8bab38275b4e974" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldIsDefined</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a942f81bdce4433198b3d9a85cdcc5416" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldIsExterior</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a3a4a4d38f3237eef5592a3fa1c436d5f" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldIsOnFace</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1573bb82ca9c8b5d8a612e7b9eeed282" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFielditerator</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a72476a7de9644f80bd770de56215750c" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldLessThan</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ada50786d7a8ed39b0bbbcbbdcd6ea64f" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldLog</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa9b65e612fd64fd1b0ef1ade93f6c806" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldMagnitude</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1acf317ad81f665b2de4844a04cf94dbd0" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldMatrixInvert</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1acf26d84404910091d9e790cb3d73ddab" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldMatrixMultiply</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a32320f95eb71c9b4498d072fe6f96ace" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldMeshIntegral</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aaf32771ad5b5ac242b2163dcb03c759c" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldMeshIntegralSquares</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac961e552c6eb79996528618a12654669" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldmodulenotifier</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae2459e5418ae59427d113c417ff06058" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldMultiply</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a8efbf42002909f9fd9139fd6aaabec99" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodeLookup</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1ae050a95887601ae11eb7059f707ddc" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodesetMaximum</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a52ad927ca7b2e3cd2a04188f850f7074" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodesetMean</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ab8224c27851cec760699fb08e2885862" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodesetMeanSquares</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a7910e69c660bdd2445e41b694877a7ae" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodesetMinimum</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a3dff60d1cb93cc0e485a8ea4cf8ef487" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodesetSum</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a22b537fd76d1aafd3033f8c4b6acdf5a" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodesetSumSquares</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a27fe2d062e7d97f06287273e104d05f5" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNodeValue</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a733d6dbe54eca2464b7d70453e060525" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNormalise</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a29dcfae8dabd2ca8758bdb762ae41609" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldNot</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae7cfd30ee552986e8b308b1796234c8d" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldOr</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a669caf254dd908d32922da01dc9aa67d" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldPower</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac544b6facdab4a83abb6278d857521ff" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldProjection</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad18d38697f927f0ab0ed25762660f171" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldSceneviewerProjection</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1a5e40429b3bf4698eb8d01dd6f3fd40" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldSin</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ab9c9aca09fd1daacb42ead12c40788b2" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldsmoothing</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a0e8e9dd60877b4d49777d7ea764da322" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldSqrt</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae5e573ea86de6957d5905ec0887ef13d" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldStoredMeshLocation</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aeff9cbb2d1f911125100c4b7328e1031" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldStoredString</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aeabaf2f7786787070e0d024da7eb4721" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldStringConstant</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a833a19d7bf1a31aba06dc247752eb518" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldSubtract</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ad1e2af3827f21a2547edcbe1baa6d1a7" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldSumComponents</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1acdb60288bae29974e227b3a090883313" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldTan</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a19279722d6969aebd174185d89670266" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldTimeLookup</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a3e7c1978bf49ddb6f6ac45a69d782275" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldTimeValue</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1adb7e848f5f1a17add234aea2624790b3" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldTranspose</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a0d002b996c78cd826e9ad74a502c3d26" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldVectorCoordinateTransformation</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9e05215afebd04b999604d2d9c143e1c" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createFieldXor</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ada3f248f916b5c561e0e567954574476" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>createOptimisation</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a5012fd4644c9b3e6eb63ac665306abaa" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>defineAllFaces</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a9629b9e5c0cd91488c1a01ccee079a64" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>endChange</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae4a5b3936bc1ea6658a8cb1f3bf34b11" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>Fieldmodule</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1676e97931c0bf1cde040462779994fc" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>Fieldmodule</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aad80e24a6f41d7c031aaaf30d1bdfffa" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>Fieldmodule</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ae426524c3e12a5bd06695e66d9ca43ba" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>findFieldByName</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a6dc9e09c4fecc6eb8cd06f074bd964ea" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>findMeshByDimension</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ac037ebc7e67c3fa9e1a56cbca0f1a368" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>findMeshByName</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1af6c34d0a96ef65be3ceefc65badab669" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>findNodesetByFieldDomainType</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a1653b3a43ce3aee0aea16af76379632e" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>findNodesetByName</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1ade54775b505383dd3eb5671eeb34a76a" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>getId</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a2cde509da78fd6a758ed7126307e5808" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>getMatchingTimesequence</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a76758a25dfb1da91ab90ced1f5c448bb" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>getRegion</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a59632afdf74a7382ba91aacbc943eb99" prot="private" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>id</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1adeb193f51bd236e99150fa49c1a3bf59" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>isValid</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1aa5418aff205c69f844077b080277fe3b" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>operator=</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a31dfb31d8d058a749dad0c8ac358d3ee" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>readDescription</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a33fd27adce35d2ed8277a4515197abc6" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>writeDescription</name></member>
      <member refid="classCMLibs_1_1Zinc_1_1Fieldmodule_1a655de99144d9b50827f6426158150ef4" prot="public" virt="non-virtual"><scope>CMLibs::Zinc::Fieldmodule</scope><name>~Fieldmodule</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
